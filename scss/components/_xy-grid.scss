// Foundation for Sites by ZURB
// foundation.zurb.com
// Licensed under MIT Open Source

////
/// @group xy-grid
////

/// The maximum width of a grid container.
/// @type Number
$grid-container: 1200px !default;

/// The number of columns used in the grid.
/// @type Number
$grid-columns: 12 !default;

/// The amount of margin between cells at different screen sizes when using the margin grid. To use just one size, set the variable to a number instead of a map.
/// @type Map | Length
$grid-margin-gutters: (
    small: 20px,
    medium: 30px
) !default;

/// The amount of padding in cells at different screen sizes when using the padding grid. To use just one size, set the variable to a number instead of a map.
/// @type Map | Length
$grid-padding-gutters: $grid-margin-gutters !default;

/// The amount of padding to use when padding the grid-container.
/// @type Map | Length
$grid-container-padding: $grid-padding-gutters !default;

/// The maximum width to apply to a grid container
/// @type Number
$grid-container-max: $grid-container !default;

/// The maximum number of cells in an XY block grid.
/// @type Number
$xy-block-grid-max: 8 !default;

/// Create gutters for a cell/container.
/// @param {Number|Map} $gutters [$grid-margin-gutters] - Map or single value for gutters.
/// @param {Keyword} $gutter-type [margin] - Type of gutter to output. Accepts either margin or padding.
/// @param {List} $gutter-position [right left] - The position to apply gutters to. Accepts `top`, `bottom`, `left`, `right` in any combination.
/// @param {Boolean} $negative [false] - Whether to apply the gutter as a negative value. Commonly used for nested grids.
@mixin xy-gutters($gutters: $grid-margin-gutters, $gutter-type: margin, $gutter-position: right left, $negative: false) {
    $operator: if($negative, '-', '');
    $gutter-type: if($negative, 'margin', $gutter-type);

    @if (type-of($gutters) == 'map') {
        @include -zf-breakpoint-value(auto, $gutters) {
            $gutter: $-zf-bp-value / 2;

            @each $value in $gutter-position {
                #{$gutter-type}-#{$value}: unquote("#{$operator}#{$gutter}");
            }
        }
    } @elseif (type-of($gutters) == 'number') {
        $gutter: $gutters / 2;

        @each $value in $gutter-position {
            #{$gutter-type}-#{$value}: unquote("#{$operator}#{$gutter}");
        }
    }
}

/// Creates a max width container, designed to house your grid content.
/// @param {Number} $width [$grid-container] - a width to limit the container to.
@mixin xy-grid-container($width: $grid-container,$padding: $grid-container-padding) {
    @include xy-gutters($gutters: $padding, $gutter-type: padding);

    max-width: $width;
    margin: 0 auto;
}

/// Creates a container for your flex cells.
/// @param {Keyword} $direction [horizontal] - Either `horizontal` or `vertical` direction of cells within.
/// @param {Boolean} $wrap [true] - If the cells within should wrap or not.
@mixin xy-grid($direction: horizontal, $wrap: true) {
    $direction: if($direction == 'horizontal', row, column);
    $wrap: if($wrap, wrap, nowrap);

    display: flex;
    flex-flow: $direction $wrap;
}

/// Calculate the percentage size of a cell.
/// @param {Number|List} $size [$grid-columns] - Size to make the cell. You can pass a value in multiple formats, such as `6`, `50%`, `1 of 2 or 1/3.
@function xy-cell-size($size: $grid-columns) {
    @if type-of($size) == 'number' {
        @if unit($size) == '%' {
            $size: $size;
        } @else if $size < 1 {
            $size: percentage($size);
        } @else {
            $size: percentage($size / $grid-columns);
        }
    } @elseif type-of($size) == 'list' {
        @if length($size) != 3 {
            @error 'Wrong syntax for xy-cell-size(). Use the format "n of n" or "n/n".';
        } @else {
            $size: percentage(nth($size, 1) / nth($size, 3));
        }
    } @else {
        @error 'Wrong syntax for xy-cell-size(). Use a number, decimal, percentage, or "n of n" / "n/n".';
    }

    @return $size;
}

/// Sets base flex properties for cells.
/// @param {Keyword} $size [full] - The size of your cell. Accepts `full`, `auto`, `shrink` or `grow`.
@mixin xy-cell-base($size: full) {
    @if ($size == 'full') {
        flex: 0 0 auto;
        min-height: 0px;
        min-width: 0px;
    } @elseif ($size == 'auto') {
        flex: 1 1 0px;
    } @elseif ($size == 'shrink') {
        flex: 0 0 auto;
    } @elseif ($size == 'grow') {
        flex: 1 0 auto;
    }
}

/// Resets a cells width (or height if vertical is true) as well as strips its gutters.
/// @param {Boolean} $vertical [false] - Set to true to output vertical (height) styles rather than widths.
@mixin xy-cell-reset($vertical: true) {
    $direction: if($vertical == true, width, height);

    #{$direction}: auto;
    max-#{$direction}: none;
}

// Sets our cell widths or heights depending on gutter type.
@mixin -xy-cell-properties($size, $margin-gutter, $vertical) {
    $direction: if($vertical == true, height, width);

    @if ($size == 'full') {
        $val: if($margin-gutter == 0, 100%, calc(100% - #{$margin-gutter}));
        #{$direction}: $val;
    } @elseif ($size == 'auto') {
        #{$direction}: auto;
        $val: if($margin-gutter == 0, 100%, calc(100% - #{$margin-gutter}));
    } @elseif ($size == 'shrink') {
        #{$direction}: auto;
    } @else {
        $val: if($margin-gutter == 0, #{xy-cell-size($size)}, calc(#{xy-cell-size($size)} - #{$margin-gutter}));
        #{$direction}: $val;
    }
}

/// Creates a cell for your grid.
/// @param {Keyword|Number} $size [full] - The size of your cell. Can be `full` (default) for 100% width, `auto` to use up available space and `shrink` to use up only required space.
/// @param {Boolean} $gutter-output [true] - Whether or not to output gutters
/// @param {Number|Map} $gutters [$grid-margin-gutters] - Map or single value for gutters.
/// @param {Keyword} $gutter-type [margin] - Map or single value for gutters.
/// @param {List} $gutter-position [right left] - The position to apply gutters to. Accepts `top`, `bottom`, `left`, `right` in any combination.
/// @param {String} $breakpoint [null] - The name of the breakpoint size in your gutters map to get the size from. If using with the `breakpoint()` mixin this will be set automatically unless manually entered.
/// @param {Boolean} $vertical [false] - Set to true to output vertical (height) styles rather than widths.
@mixin xy-cell($size: full, $gutter-output: true, $gutters: $grid-margin-gutters, $gutter-type: margin, $gutter-position: right left, $breakpoint: null, $vertical: false) {
    @if ($breakpoint == null) {
        @if (variable-exists(-zf-size) and type-of($-zf-size) != 'number') and $-zf-size != null {
            $breakpoint: $-zf-size;
        } @else {
            $breakpoint: $-zf-zero-breakpoint;
        }
    }

    $gutter: -zf-get-bp-val($gutters, $breakpoint);

    @if ($gutter != null) {
        @include xy-cell-base($size);

        @if ($gutter-type == 'margin') {
            @include -xy-cell-properties($size, $gutter, $vertical);
        } @else {
            @include -xy-cell-properties($size, 0, $vertical);
        }

        @if $gutter-output {
            @include xy-gutters($gutter, $gutter-type, $gutter-position);
        }
    } @else {
        @warn 'xy-cell: no gutters were found in `$gutters` for "$breakpoint: #{$breakpoint}", cell was not generated`';
    }
}

/// Creates a single breakpoint sized grid. Used to generate our grid classes.
/// @param {Keyword|Number} $size [full] - The size of your cell. Can be `full` (default) for 100% width, `auto` to use up available space and `shrink` to use up only required space.
/// @param {Boolean} $gutter-output [true] - Whether or not to output gutters
/// @param {Number|Map} $gutters [$grid-margin-gutters] - Map or single value for gutters.
/// @param {Keyword} $gutter-type [margin] - Map or single value for gutters.
/// @param {String} $breakpoint [null] - The name of the breakpoint size in your gutters map to get the size from. If using with the `breakpoint()` mixin this will be set automatically unless manually entered.
/// @param {Boolean} $vertical [false] - Set to true to output vertical (height) styles rather than widths.
@mixin xy-cell-static($size: full, $gutter-output: true, $gutters: $grid-margin-gutters, $gutter-type: margin, $breakpoint: $-zf-zero-breakpoint, $vertical: false) {
    $gutter: -zf-get-bp-val($gutters, $breakpoint);
    $gutter-position: if($vertical == true, top bottom, left right);

    @if ($gutter-type == 'margin') {
        @include -xy-cell-properties($size, $gutter, $vertical);
    } @else {
        @include -xy-cell-properties($size, 0, $vertical);
    }

    @if ($gutter-output) {
        // TODO: Figure out if we need to pass breakpoint in here too.
        @include xy-gutters($gutter, $gutter-type, $gutter-position);
    }
}

/// Modifies a grid to give it "frame" behavior (no overflow, no wrap, stretch behavior)
/// @param {Boolean} $vertical [false] - Is grid vertical or horizontal. Should match grid.
/// @param {Boolean} $nested [false] - Is grid nested or not. If nested is true this sets the frame to 100% height, otherwise will be 100vh.
/// @param {Number|Map} $gutters [null] - Map or single value for gutters.
/// @param {String} $breakpoint [null] - The name of the breakpoint size in your gutters map to get the size from.
/// @param {Boolean} $include-base [true] - Include the base styles that don't vary per breakpoint.
@mixin xy-grid-frame($vertical: false, $nested: false, $gutters: null, $breakpoint: null, $include-base: true) {
    @if $include-base {
        overflow: hidden;
        position: relative;
        flex-wrap: nowrap;
        align-items: stretch;
    }

    @if $breakpoint == null and type-of($gutters) == 'map' {
        @include -zf-each-breakpoint() {
            @include xy-grid-frame($vertical, $nested, $gutters, $-zf-size, false);
        }
    } @else {
        $gutter: -zf-get-bp-val($gutters, $breakpoint);

        @if $gutter {
            @if $vertical == true {
                $unit: if($nested == true, 100%, 100vh);
                $gutter: $gutter;
                height: calc(#{$unit} + #{$gutter});
            } @else {
                $unit: if($nested == true, 100%, 100vw);
                $gutter: $gutter;
                width: calc(#{$unit} + #{$gutter});
            }
        } @else {
            @if $vertical == true {
                height: if($nested == true, 100%, 100vh);
            } @else {
                width: if($nested == true, 100%, 100vw);
            }
        }
    }
}

/// Modifies a cell to give it "block" behavior (overflow auto, inertial scrolling)
/// @param {Boolean} $vertical [false] - Is grid vertical or horizontal. Should match grid.
@mixin xy-cell-block($vertical: false) {
    $property: if($vertical == true, 'overflow-y', 'overflow-x');

    @if $vertical == true {
        overflow-y: auto;
        max-height: 100%;
        min-height: 100%;
    } @else {
        overflow-x: auto;
        max-width: 100%;
    }
    -webkit-overflow-scrolling: touch;
    -ms-overflow-stype: -ms-autohiding-scrollbar;
}

/// Container for inside a grid frame containing multiple blocks. Typically used
/// as a modifier for a `.cell` to allow the cell to pass along flex sizing
/// constraints / from parents to children.
@mixin xy-cell-block-container() {
    display: flex;
    flex-direction: column;
    max-height: 100%;

    > .grid-x {
        max-height: 100%;
        flex-wrap: nowrap;
    }
}

/// Offsets a column to the right/bottom by `$n` columns.
/// @param {Number|List} $n - Size to offset by. You can pass in any value accepted by the `zf-cell()` mixin, such as `6`, `50%`, or `1 of 2`.
/// @param {Boolean} $vertical [false] Sets the direction of the offset. If set to true will apply margin-top instead.
@mixin xy-cell-offset($n, $gutters: $grid-margin-gutters, $gutter-type: margin, $breakpoint: $-zf-zero-breakpoint, $vertical: false) {
    $direction: if($vertical, 'top', $global-left);

    @include -zf-breakpoint-value($breakpoint, $gutters) {
        $gutter: $-zf-bp-value / 2;
        $size: if($gutter-type == 'margin', calc(#{xy-cell-size($n)} + #{$gutter}), #{xy-cell-size($n)});
        margin-#{$direction}: #{$size};
    }
}

/// Sizes child elements so that `$n` number of items appear on each row.
/// @param {Number} $n - Number of elements to display per row.
/// @param {String} $selector ['.cell'] - Selector(s) to use for child elements.
/// @param {Boolean} $gutter-output [true] - Whether or not to output gutters
/// @param {Number|Map} $gutters [$grid-margin-gutters] - Map or single value for gutters.
/// @param {Keyword} $gutter-type [margin] - Type of gutter to output. Accepts `margin` or `padding`.
/// @param {List} $gutter-position [right left] - The position to apply gutters to. Accepts `top`, `bottom`, `left`, `right` in any combination.
/// @param {Boolean} $vertical [false] - Set to true to output vertical (height) styles rather than widths.
@mixin xy-grid-layout($n, $selector: '.cell', $gutter-output: true, $gutters: $grid-margin-gutters, $gutter-type: margin, $gutter-position: right left, $breakpoint: $-zf-zero-breakpoint, $vertical: false) {
    $size: percentage(1/$n);

    & > #{$selector} {
        @include xy-cell($size, $gutter-output, $gutters, $gutter-type, $gutter-position, $breakpoint, $vertical);
    }
}

/// Collapses the grid a cells within it.
/// @param {String} $selector [.cell] - The child element to remove the gutter from.
/// @param {Keyword} $gutter-type [margin] - The type of gutter to remove.
/// @param {List} $gutter-position [right left] - The positions to remove gutters from. Accepts `top`, `bottom`, `left`, `right` in any combination.
@mixin xy-grid-collapse($selector: '.cell', $gutter-type: margin, $gutter-position: right left, $min-breakpoint: $-zf-zero-breakpoint) {
    @if ($gutter-type == 'margin') {
        @include breakpoint($min-breakpoint) {
            @each $value in $gutter-position {
                margin-#{$value}: 0;
            }

            > #{$selector} {
                @each $value in $gutter-position {
                    margin-#{$value}: 0;
                }
            }
        }

        $excluded-bps: -zf-breakpoints-less-than($min-breakpoint);

        @each $bp in $breakpoint-classes {
            @if (sl-contain($excluded-bps, $bp)) {
                @include breakpoint($min-breakpoint) {
                    @for $i from 1 through $grid-columns {
                        > .#{$bp}-#{$i} {
                            @include xy-cell-static($i, $gutter-output: false, $gutter-type: padding);
                        }
                    }
                }
            } @else {
                @include breakpoint($bp) {
                    @for $i from 1 through $grid-columns {
                        > .#{$bp}-#{$i} {
                            @include xy-cell-static($i, $gutter-output: false, $gutter-type: padding);
                        }
                    }
                }
            }
        }
    } @else {
        @include breakpoint($min-breakpoint) {
            @each $value in $gutter-position {
                margin-#{$value}: 0;
            }

            > #{$selector} {
                @each $value in $gutter-position {
                    padding-#{$value}: 0;
                }
            }
        }
    }
}

// Margin Grid classes
@mixin xy-base-grid-classes {
    .grid-container {
        @include xy-grid-container;

        &.fluid {
            @include xy-grid-container(100%);
        }

        &.full {
            @include xy-grid-container(100%, 0);
        }
    }

    .grid-x {
        @include xy-grid;
    }

    .cell {
        @include xy-cell-base();
        @include xy-cell-static($grid-columns, false, $gutter-type: padding);

        &.auto {
            @include xy-cell-base(auto);
        }

        &.shrink {
            @include xy-cell-base(shrink);
        }
    }

    .grid-x {
        > .auto {
            @include xy-cell-static(auto, false);
        }

        > .shrink {
            @include xy-cell-static(shrink, false);
        }
    }

    @include -zf-each-breakpoint() {
        .grid-x {
            $str: "> .#{$-zf-size}-shrink, > .#{$-zf-size}-full";
            @for $i from 1 through $grid-columns {
                $str: $str + ", > .#{$-zf-size}-#{$i}";
            }

            #{$str} {
                flex-basis: auto;
            }
        }
    }

    @include -zf-each-breakpoint() {
        @if not($-zf-size == small) {
            .grid-x > .#{$-zf-size}-auto {
                @include xy-cell-base(auto);
                @include xy-cell-static(auto, false);
            }

            .grid-x > .#{$-zf-size}-shrink {
                @include xy-cell-base(shrink);
                @include xy-cell-static(shrink, false);
            }
        }

        @for $i from 1 through $grid-columns {
            .grid-x > .#{$-zf-size}-#{$i} {
                @include xy-cell-base(shrink);
                @include xy-cell-static($i, false, $gutter-type: padding);
            }
        }
    }

    .grid-margin-x:not(.grid-x) > .cell {
        width: auto;
    }

    .grid-margin-y:not(.grid-y) > .cell {
        height: auto;
    }
}

@mixin -xy-breakpoint-cell-classes($class-breakpoint, $gutter-breakpoint, $vertical) {
    $prefix: if($class-breakpoint == $-zf-zero-breakpoint, '', '#{$class-breakpoint}-');

    > .#{$prefix}auto {
        @include xy-cell-static(auto, false, $breakpoint: $gutter-breakpoint, $vertical: $vertical);
    }

    > .#{$prefix}shrink {
        @include xy-cell-static(shrink, false, $breakpoint: $gutter-breakpoint, $vertical: $vertical);
    }

    @for $i from 1 through $grid-columns {
        $classname: if($vertical, '.#{$class-breakpoint}-#{$i}', '.#{$class-breakpoint}-#{$i}');

        > #{$classname} {
            @include xy-cell-static($i, false, $breakpoint: $gutter-breakpoint, $vertical: $vertical);
        }
    }
}

// Margin Grid classes
@mixin xy-margin-grid-classes($gutter-position: left right, $vertical: false, $wrapping-selector: '.grid-margin-x') {
    #{$wrapping-selector} {
        @include xy-gutters($negative: true, $gutter-position: $gutter-position);

        > .cell {
            @include xy-cell-static($vertical: $vertical);
        }

        @include -zf-each-breakpoint() {
            @if (type-of($grid-margin-gutters) == 'map' and map-has-key($grid-margin-gutters, $-zf-size) and $-zf-size != $-zf-zero-breakpoint) {
                > .cell {
                    @include xy-cell-static($breakpoint: $-zf-size, $vertical: $vertical);
                }
            }
        }

        @include -zf-each-breakpoint() {
            @if (type-of($grid-margin-gutters) == 'map' and map-has-key($grid-margin-gutters, $-zf-size)) {
                @each $bp in -zf-breakpoints-less-than($-zf-size) {
                    @if (map-has-key($grid-margin-gutters, $bp)) {
                        @include -xy-breakpoint-cell-classes($bp, $-zf-size, $vertical);
                    }
                }
            }

            @include -xy-breakpoint-cell-classes($-zf-size, $-zf-size, $vertical);
        }
    }
}

// Padding Grid classes
@mixin xy-padding-grid-classes {
    .grid-padding-x {

        .grid-padding-x {
            @include xy-gutters($negative: true);
        }

        .grid-container:not(.full) > & {
            @include xy-gutters($negative: true);
        }

        > .cell {
            @include xy-gutters($gutters: $grid-padding-gutters, $gutter-type: padding);
        }
    }
}

// Block Grid classes
@mixin xy-block-grid-classes($margin-grid: true, $padding-grid: true) {
    @if $padding-grid {
        @include -zf-each-breakpoint {
            @for $i from 1 through $xy-block-grid-max {
                .#{$-zf-size}-up-#{$i} {
                    @include xy-grid-layout($i, '.cell', false, $gutter-type: padding);
                }
            }
        }
    }

    @if $margin-grid {
        @include -zf-each-breakpoint {
            @for $i from 1 through $xy-block-grid-max {
                @if(type-of($grid-margin-gutters) == 'map' and map-has-key($grid-margin-gutters, $-zf-size)) {
                    @each $bp in -zf-breakpoints-less-than($-zf-size) {
                        @if (map-has-key($grid-margin-gutters, $bp)) {
                            .grid-margin-x.#{$bp}-up-#{$i} {
                                @include xy-grid-layout($i, '.cell', false, $gutter-type: margin, $breakpoint: $bp);
                            }
                        }
                    }
                }
            }

            @for $i from 1 through $xy-block-grid-max {
                .grid-margin-x.#{$-zf-size}-up-#{$i} {
                    @include xy-grid-layout($i, '.cell', false, $gutter-type: margin, $breakpoint: $-zf-size);
                }
            }
        }
    }
}

// Collapse classes
@mixin xy-collapse-grid-classes($margin-grid: true, $padding-grid: true) {
    @each $bp in $breakpoint-classes {
        @if $margin-grid {
            .#{$bp}-margin-collapse {
                @include xy-grid-collapse($gutter-type: margin, $min-breakpoint: $bp);
            }
        }

        @if $padding-grid {
            .#{$bp}-padding-collapse {
                @include xy-grid-collapse($gutter-type: padding, $min-breakpoint: $bp);
            }
        }
    }
}

// Offset classes
@mixin xy-offset-cell-classes {
    @include -zf-each-breakpoint {
        @for $i from 1 through $grid-columns {
            $o: $i - 1;

            .#{$-zf-size}-offset-#{$o} {
                @include xy-cell-offset($o, $gutters: $grid-padding-gutters, $gutter-type: padding, $breakpoint: $-zf-size);
            }

            .grid-margin-x > .#{$-zf-size}-offset-#{$o} {
                @include xy-cell-offset($o, $breakpoint: $-zf-size);
            }
        }
    }
}

// Vertical Grid classes
@mixin xy-vertical-grid-classes($margin-grid: true, $padding-grid: true) {
    @include -zf-each-breakpoint() {
        @if not($-zf-size == small) {}
    }

    .grid-y {
        @include xy-grid(vertical, false);

        > .cell {
            @include xy-cell-reset();
        }

        > .auto {
            @include xy-cell-static(auto, false, $breakpoint: $-zf-size, $vertical: true);
        }

        > .shrink {
            @include xy-cell-static(shrink, false, $breakpoint: $-zf-size, $vertical: true);
        }

        @include -zf-each-breakpoint() {
            $str: "> .#{$-zf-size}-shrink, > .#{$-zf-size}-full";

            @for $i from 1 through $grid-columns {
                $str: $str + ", > .#{$-zf-size}-#{$i}";
            }

            #{$str} {
                flex-basis: auto;
            }
        }

        @include -zf-each-breakpoint() {
            @if not($-zf-size == small) {
                > .#{$-zf-size}-auto {
                    @include xy-cell-base(auto);
                    @include xy-cell-static(auto, false, $breakpoint: $-zf-size, $vertical: true);
                }

                > .#{$-zf-size}-shrink {
                    @include xy-cell-static(shrink, false, $breakpoint: $-zf-size, $vertical: true);
                }
            }

            @for $i from 1 through $grid-columns {
                > .#{$-zf-size}-#{$i} {
                    @include xy-cell-static($i, false, $vertical: true, $gutter-type: padding);
                }
            }
        }
    }

    @if $padding-grid {
        .grid-padding-y {
            .grid-padding-y {
                @include xy-gutters($negative: true, $gutter-position: top bottom);
            }

            > .cell {
                @include xy-gutters($gutters: $grid-padding-gutters, $gutter-type: padding, $gutter-position: top bottom);
            }
        }
    }

    @if $margin-grid {
        @include xy-margin-grid-classes(top bottom, true, '.grid-margin-y');
    }
}

@mixin xy-frame-grid-classes($vertical-grid: true, $margin-grid: true) {
    .grid-frame {
        @include xy-grid-frame;
    }

    .cell .grid-frame {
        width: 100%;
    }

    .cell-block {
        @include xy-cell-block();
    }

    .cell-block-y {
        @include xy-cell-block(true);
    }

    .cell-block-container {
        @include xy-cell-block-container();
    }


    @include -zf-each-breakpoint(false) {
        .#{$-zf-size}-grid-frame {
            @include xy-grid-frame;
        }

        .cell .#{$-zf-size}-grid-frame {
            width: 100%;
        }

        .#{$-zf-size}-cell-block {
            @include xy-cell-block();
        }

        .#{$-zf-size}-cell-block-container {
            @include xy-cell-block-container();
        }

        .#{$-zf-size}-cell-block-y {
            @include xy-cell-block(true);
        }
    }

    @if $vertical-grid {
        .grid-y {
            &.grid-frame {
                width: auto;
                @include xy-grid-frame(true);
            }

            @include -zf-each-breakpoint(false) {
                &.#{$-zf-size}-grid-frame {
                    width: auto;
                    @include xy-grid-frame(true);
                }
            }
        }

        .cell {
            .grid-y.grid-frame {
                height: 100%;
            }

            @include -zf-each-breakpoint(false) {
                .grid-y.#{$-zf-size}-grid-frame {
                    height: 100%;
                }
            }
        }
    }

    @if $margin-grid {
        @include xy-margin-grid-classes(top bottom, true, '.grid-margin-y');

        .grid-frame.grid-margin-y {
            @include xy-grid-frame(true, false, $grid-margin-gutters, $include-base: false);
        }

        @include -zf-each-breakpoint(false) {
            .grid-margin-y.#{$-zf-size}-grid-frame {
                @include xy-grid-frame(true, false, $grid-margin-gutters, $-zf-size, false);
            }
        }
    }
}

// Outputs CSS classes for the xy-grid.
@mixin foundation-xy-grid-classes($base-grid: true, $margin-grid: true, $padding-grid: true, $block-grid: true, $collapse: true, $offset: true, $vertical-grid: true, $frame-grid: true) {

    @if ($base-grid) {
        @include xy-base-grid-classes();
    }

    @if ($margin-grid) {
        @include xy-margin-grid-classes();
    }

    @if ($padding-grid) {
        @include xy-padding-grid-classes();
    }

    @if ($block-grid) {
        @include xy-block-grid-classes($margin-grid, $padding-grid);
    }

    @if ($collapse) {
        @include xy-collapse-grid-classes($margin-grid, $padding-grid);
    }

    @if ($offset) {
        @include xy-offset-cell-classes();
    }

    @if ($vertical-grid) {
        @include xy-vertical-grid-classes($margin-grid, $padding-grid);
    }

    @if ($frame-grid) {
        @include xy-frame-grid-classes($vertical-grid, $margin-grid)
    }
}
